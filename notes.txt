-Provider
-Consumer Widget;  do magic instead of build the whole widget, only consumer widget will get build.

-Example
 final countProvider = Provider.of<CountProvider>(context, listen: false);
     // where ever we create the object of Provider it starts listening to changes and build the whole widget in which it is created.
     // like in the above case countProvider is initialized with Provider, now whenever any changes happens it will rebuild the Widget build()
     // but we don't want to rebuild the whole widget, we only want to rebuild the widget where changes are actually happened,
     // - Provider.of<CountProvider>(context, listen: false); // so setting the listen = false, will stop it to listen the changes
     // & now will only rebuild the Consumer widget with its provider e.g :- Consumer<CountProvider>(builder: (context, value, child){}

=> Added ExampleOneScreen ExampleOneProvider.
now we have to update the changeNotifierProvider() in build of main(),
because now we don't have a single provider instead we have multiple providers in our app
// just change the method , instead of changeNotifierProvider() use MultiProvider()

-In ExampleOneScreen's build method, no need to create object of Provider like below:
    //final provider = Provider.of<ExampleOneProvider>(context, listen: false);
  because when we use Consumer Widget, we have to pass the builder like below:
    // Consumer(
         builder: (context, value, child){
            // here we can do the same work of provider using value argument like below
            value.setValue() , value.getValue, etc;
            // so no need to initialize the provider like this: final provider = Provider.of<ExampleOneProvider>(context, listen: false);
         }
       )

=> Changing the theme Using provider

=>